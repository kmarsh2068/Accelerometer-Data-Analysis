import os
import pandas as pd
import matplotlib.pyplot as plt
from scipy.signal import find_peaks
import tkinter as tk
from tkinter import filedialog, simpledialog, messagebox
import numpy as np

def choose_file():
    root = tk.Tk()
    root.withdraw()
    filename = filedialog.askopenfilename(
        title="Select accelerometer file",
        filetypes=[
            ("CSV and TXT Files", "*.csv *.txt"),
            ("CSV Files", "*.csv"),
            ("Text Files", "*.txt"),
            ("All Files", "*.*"),
        ]
    )
    root.destroy()
    return filename

def parse_wit_ble_txt(file_path):
    df = pd.read_csv(file_path, sep='\t')
    required_cols = ["time", "AccX(g)", "AccY(g)", "AccZ(g)"]
    missing_cols = [c for c in required_cols if c not in df.columns]
    if missing_cols:
        print("Missing columns: {}".format(", ".join(missing_cols)))
        return [], pd.DataFrame()

    df["time"] = pd.to_datetime(df["time"], errors="coerce")
    for col in ["AccX(g)", "AccY(g)", "AccZ(g)"]:
        df[col] = pd.to_numeric(df[col], errors="coerce")

    df = df.dropna(subset=required_cols)
    if df.empty:
        return [], pd.DataFrame()

    start_time = df["time"].iloc[0]
    times = (df["time"] - start_time).dt.total_seconds().tolist()
    return times, df[["AccX(g)", "AccY(g)", "AccZ(g)"]]

def read_csv_data(filename):
    df = pd.read_csv(filename)
    if df.shape[1] < 2:
        print("CSV file does not have enough columns.")
        return [], pd.DataFrame()
    
    time_col = df.columns[0]
    df = df.rename(columns={df.columns[1]: "AccX(g)"})
    df["time"] = pd.to_numeric(df[time_col], errors="coerce")
    df["AccX(g)"] = pd.to_numeric(df["AccX(g)"], errors="coerce")
    df = df.dropna()
    times = df["time"].tolist()
    return times, df[["AccX(g)"]]

def find_peaks_filtered(signal, prominence=0.25, distance=25, trim_start=0.05, trim_end=0.20):
    n = len(signal)
    if n == 0:
        return [], 0
    start = int(n * trim_start)
    end = int(n * (1 - trim_end))
    if end <= start:
        start = 0
        end = n
    segment = signal[start:end].reset_index(drop=True)
    peaks, props = find_peaks(segment, prominence=prominence, distance=distance)
    peaks = [p + start for p in peaks]
    return peaks, len(peaks)

def compute_step_times(times, peaks):
    if len(peaks) < 2:
        return [], None
    intervals = [times[peaks[i+1]] - times[peaks[i]] for i in range(len(peaks)-1)]
    avg_interval = sum(intervals) / len(intervals)
    return intervals, avg_interval

def pick_best_axis_and_get_peaks(times, df, trim_start=0.05, trim_end=0.20):
    best = {
        "axis": None,
        "peaks": [],
        "n_peaks": 0,
        "z_scores": None
    }
    for col in df.columns:
        accels = df[col].reset_index(drop=True)
        mean_val = np.mean(accels)
        std_val = np.std(accels)
        if std_val == 0:
            continue
        z_scores = (accels - mean_val) / std_val
        peaks, total_peaks = find_peaks_filtered(z_scores, trim_start=trim_start, trim_end=trim_end)
        if total_peaks > best["n_peaks"]:
            best.update({
                "axis": col,
                "peaks": peaks,
                "n_peaks": total_peaks,
                "z_scores": z_scores
            })
    return best

def plot_three_axes(times, df, filename, trim_start=0.05, trim_end=0.20):
    best = pick_best_axis_and_get_peaks(times, df, trim_start=trim_start, trim_end=trim_end)

    if best["axis"] is None or best["n_peaks"] == 0:
        print("No usable axis or no peaks detected.")
        plt.figure(figsize=(10,4))
        for col in df.columns:
            accels = df[col].reset_index(drop=True)
            if np.std(accels) == 0:
                continue
            z_scores = (accels - np.mean(accels)) / np.std(accels)
            plt.plot(times[:len(z_scores)], z_scores, label=col)
        plt.title("Normalized accelerometer axes (no peaks detected)")
        plt.xlabel("Time (s)")
        plt.legend()
        plt.show()
        return

    axis = best["axis"]
    peaks = best["peaks"]
    z_scores = best["z_scores"]
    intervals, avg_interval = compute_step_times(times, peaks)
    total_steps = len(peaks)

    print(f"Chosen axis: {axis} with {total_steps} peaks.")
    if avg_interval is not None:
        print(f"Average step interval: {avg_interval:.3f} s")
    else:
        print("Not enough peaks to compute an average interval.")

    root = tk.Tk()
    root.withdraw()
    prompt = f"Detected {total_steps} steps on axis {axis}.\nEnter total distance of the track (same units as you want displayed):"
    total_distance = simpledialog.askfloat("Total Distance", prompt, minvalue=0.0, parent=root)
    root.destroy()
    if total_distance is None:
        print("User cancelled distance entry. Skipping step model visualization.")
        plt.figure(figsize=(10,4))
        plt.plot(times[:len(z_scores)], z_scores, label=f"{axis} (steps={total_steps})")
        plt.scatter([times[i] for i in peaks], [z_scores.iloc[i] for i in peaks], color='red')
        plt.title(f"Z-Score Normalized: {os.path.basename(filename)} ({axis})")
        plt.xlabel("Time (s)")
        plt.ylabel("Z-score")
        plt.legend()
        plt.show()
        return

    if total_steps >= 2:
        positions = np.linspace(0, total_distance, total_steps)
    else:
        positions = np.array([total_distance / 2.0])

    fig = plt.figure(figsize=(12, 6))
    gs = fig.add_gridspec(3, 4)

    ax_track = fig.add_subplot(gs[:, :3])  
    ax_info = fig.add_subplot(gs[0, 3])     
    ax_ts = fig.add_subplot(gs[1:, 3])      

    ax_track.plot([0, total_distance], [0, 0], linewidth=2, color='black') 
    ax_track.scatter(positions, np.zeros_like(positions), s=80, zorder=5, label='Steps')
    for i, x in enumerate(positions):
        ax_track.text(x, 0.05, str(i+1), ha='center', va='bottom', fontsize=9)

    if len(intervals) > 0:
        for i, delta_t in enumerate(intervals):
            mid = (positions[i] + positions[i+1]) / 2.0
            ax_track.annotate(f"{delta_t:.2f}s", xy=(mid, 0), xytext=(mid, 0.12),
                              ha='center', va='bottom', fontsize=9,
                              arrowprops=dict(arrowstyle="-", lw=0.5, color='gray', shrinkA=0, shrinkB=0))
    else:
        ax_track.text(total_distance/2.0, 0.15, "No intervals (not enough steps)",
                      ha='center', va='bottom', fontsize=10, color='red')

    ax_track.set_ylim(-0.5, 0.8)
    ax_track.set_yticks([])
    ax_track.set_xlabel(f"Distance (units entered)")
    ax_track.set_title("Step visual model")

    ax_info.axis('off')
    info_text = (
        f"File: {os.path.basename(filename)}\n\n"
        f"Axis used: {axis}\n"
        f"Total steps: {total_steps}\n"
        f"Avg interval: {avg_interval:.2f}s\n" if avg_interval is not None else f"Avg interval: N/A\n"
    )
    info_text += f"Total distance: {total_distance}\n"
    ax_info.text(0.5, 0.5, info_text, ha='center', va='center', fontsize=10, bbox=dict(boxstyle="round", fc="wheat", ec="0.5"))

    ax_ts.plot(times[:len(z_scores)], z_scores, label=axis)
    ax_ts.scatter([times[i] for i in peaks], [z_scores.iloc[i] for i in peaks], color='red', s=20)
    ax_ts.set_xlabel("Time (s)")
    ax_ts.set_ylabel("Z-score")
    ax_ts.set_title("Accelerometer Chart")
    ax_ts.grid(True)

    plt.tight_layout()
    plt.show()

def main_loop():
    while True:
        filename = choose_file()
        if not filename:
            break

        ext = os.path.splitext(filename)[1].lower()
        if ext == ".txt":
            times, df_acc = parse_wit_ble_txt(filename)
            if not df_acc.empty and len(times) > 0:
                plot_three_axes(times, df_acc, filename)
            else:
                messagebox.showerror("Error", "No valid data in TXT file.")
        elif ext == ".csv":
            times, df_acc = read_csv_data(filename)
            if not df_acc.empty and len(times) > 0:
                plot_three_axes(times, df_acc, filename)
            else:
                messagebox.showerror("Error", "No valid data in CSV file.")
        else:
            messagebox.showwarning("Unsupported", "Unsupported file type. Please select .csv or .txt")

        again = input("Load another file? (y/n): ").strip().lower()
        if again != "y":
            break

if __name__ == "__main__":
    main_loop()
